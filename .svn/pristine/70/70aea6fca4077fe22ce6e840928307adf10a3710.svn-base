//server.c//
//------------//
//This file contains the main server-side functionality
//------------//

#include <csse2310a4.h>
#include <csse2310a3.h>
#include "clientList.h"
#include "shared.h"
#include "stringmap.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>

//useful constants
#define MIN_NUM_ARGS 2
#define MAX_NUM_ARGS 3
#define INVALID_NUM -1
#define CONNECTIONS_INDEX 1
#define PORTNUM_INDEX 2
#define MIN_PORT 1024
#define MAX_PORT 65535
#define TCP 0
#define DEFAULT_PORT 0
#define HOST_IP "localhost"
#define SPACE ' '
#define NAME_CMD "name"
#define SUB_CMD "sub"
#define UNSUB_CMD "unsub"
#define PUB_CMD "pub"
#define INVALID_MSG ":invalid\n"

//server error codes
enum ErrorCodes {
    SUCCESS,
    USAGE_ERROR,
    PORTNUM_ERROR
};

/* Defines the Parameters structure which holds the following command line
 * arguments given to psserver:
 *      
 *      maxConnections - maximum number of concurrent connections to server
 *                    permitted
 *      portnum - indicates which localhost port psserver is listening on
 *      service - string version of portnum
 * */
typedef struct { 
    int maxConnections;
    int portnum;
    char* service;
} Parameters;


/* general_error
 * -------------
 * For a given error (encoded by 'errorCode'), print out a descrptive message
 * and exit with the appropriate code.
 *
 * errorCode - encodes the specific error being handled
 * */
void general_error(int errorCode) {
    switch (errorCode) {
        case USAGE_ERROR:
            fprintf(stderr, "Usage: psserver connections [portnum]\n");
            exit(USAGE_ERROR);
        case PORTNUM_ERROR:
            fprintf(stderr, "psserver: unable to open socket for listening\n");
            exit(PORTNUM_ERROR);
    }
    return;
}

/* string_to_int 
 * ---------------
 * Attempts to convert the given string to a non-negative integer
 *
 * str - string to be converted
 *
 * Returns:
 *      - -1 if the string cannot be converted to a non-negative integer OR;
 *      - the integer if it CAN BE converted
 * */
int string_to_int(char* str) {
    //handle portnum = 0 case
    if (str[0] == '0') {
        return 0;
    }
    //handle all other cases
    //checks all characters are digits
    for (int i = 0; i < strlen(str); i++) {
        if (!isdigit(str[i])) {
            return INVALID_NUM;
        }
    }
    return atoi(str);
}

/* parse_command_line
 * ------------------
 * Retreives the command line arguments given to psserver and populates 
 * a Parameters structure with said arguments.
 *
 * NOTE: validity of all arguments is checked for 
 * 
 * argc - number of command line arguments
 * argv - array of command line arguments
 *
 * Returns:
 *      a Parameters structure populated with the given command line args
 * 
 * Exits with:
 *      1 - incorrect number of args received, connections arg not 
 *          non-negative integer or port number out of range
 * */
Parameters parse_command_line(int argc, char** argv) {
    //check number of args given is valid
    if (!(argc >= MIN_NUM_ARGS && argc <= MAX_NUM_ARGS)) {
        general_error(USAGE_ERROR); 
    }

    int portnum = DEFAULT_PORT;
    char* service = NULL;
    int maxConnections = string_to_int(argv[CONNECTIONS_INDEX]);
    
    //check connections arg is valid
    if (maxConnections == INVALID_NUM) {
        general_error(USAGE_ERROR); 
    }

    //check portnum is valid
    if (argc == MAX_NUM_ARGS) {
        service = argv[PORTNUM_INDEX];
        portnum = string_to_int(argv[PORTNUM_INDEX]);
        //not a non-negative integer
        if (portnum == INVALID_NUM) {
            general_error(USAGE_ERROR);
        }
        //not in range
        if (!(portnum == DEFAULT_PORT  || 
                    (portnum >= MIN_PORT && portnum <= MAX_PORT))) {
           general_error(USAGE_ERROR); 
        }
    }
    //if reached this point, all args are valid
    //NOTE: still haven't checked whether psserver can open the given port
    Parameters cmdArgs;
    memset(&cmdArgs, 0, sizeof(Parameters));
    cmdArgs.maxConnections = maxConnections;
    cmdArgs.portnum = portnum;
    //if portnum is 0, service should be NULL
    cmdArgs.service = portnum ? service : NULL;

    return cmdArgs;
}

int open_socket(Parameters cmdArgs) {
    //get address info of port to listen on 
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET; //IPv4
    hints.ai_socktype = SOCK_STREAM; //byte stream (TCP)
    hints.ai_flags = AI_PASSIVE; //listen on all server's interfaces (IP's)
    if (getaddrinfo(HOST_IP, cmdArgs.service, &hints, &ai)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //create socket, allow its rapid reuse and bind to given port
    int listeningFd = socket(AF_INET, SOCK_STREAM, TCP);
    int optVal = 1; 
    setsockopt(listeningFd, SOL_SOCKET, SO_REUSEADDR, &optVal, sizeof(int));
    bind(listeningFd, (struct sockaddr*)ai->ai_addr, sizeof(struct sockaddr));

    //retreive which port we're listening on 
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(struct sockaddr_in));
    socklen_t addrLen = sizeof(struct sockaddr_in);
    if (getsockname(listeningFd, (struct sockaddr*) &addr, &addrLen)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //indicate socket is willing to accept connections
    if (listen(listeningFd, cmdArgs.maxConnections) < 0) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }
    
    //print port listening on and return socket fd
    printf("%u\n", ntohs(addr.sin_port));
    return listeningFd;
}

void handle_name_cmd(Client* client, char* name) { 
    //ignore duplicate name
    if (client->name) {
        return; 
    } 
    client->name = name;
    return;
}

bool handle_sub_cmd(Client* client, StringMap* sm, char* topic) { 
    StringMapItem* currItem = NULL;
    while ((currItem = stringmap_iterate(sm, currItem))) {
        if (!strcmp(currItem->key, topic)) {
            //printf("adding client to %s\n", currItem->key);
            add_client(currItem->item, client);            
            return true;
        }
    }
    //topic doesn't exist - create it
    ListItem* head = init_client_list(client, false);
    return stringmap_add(sm, topic, head);
}

bool handle_unsub_cmd(Client* client, StringMap* sm, char* topic) { 
    StringMapItem* currItem = NULL;
    while ((currItem = stringmap_iterate(sm, currItem))) {
        if (!strcmp(currItem->key, topic)) {
            ListItem* newHead = remove_client(currItem->item, client);
            //replace old list with new list returned from remove_client()
            if (newHead) {
                currItem->item = newHead;
            }
            //will be NULL if client wasn't in list
            return newHead;
        }
    }
    //topic doesn't exist
    return false;
}

bool handle_pub_cmd(Client* client, StringMap* sm, char* topic, char* value) {
    StringMapItem* mapItem = NULL;
    while ((mapItem = stringmap_iterate(sm, mapItem))) {
        if (!strcmp(mapItem->key, topic)) {
            //loop through the list of all clients subbed to the topic
            ListItem* clientItem = mapItem->item;
            while (clientItem) {
                Client* currClient = clientItem->client;
                //don't send to placeholders
                if (currClient) {
                    fprintf(currClient->serverToClient, "%s:%s:%s\n",
                            client->name, topic, value);
                }

                clientItem = clientItem->next;
            }
            return true;
        }
    }
    //topic doesn't exit
    return false;
}

void handle_client_msg(char* msg, Client* client, StringMap* stringMap) {
    char** toks = split_line(strdup(msg), SPACE);
    int toksLen = string_array_length(toks);
    if (toksLen < 2 || toksLen > 3) {
        fprintf(client->serverToClient, INVALID_MSG);
        fflush(client->serverToClient);
        return;
    }

    //handle each of the command types
    char* cmd = toks[0];
    //name 
    if (!strcmp(cmd, NAME_CMD) && toksLen == 2 &&
            !has_space_colon_newline(toks[1])) {

        handle_name_cmd(client, toks[1]);
        fflush(client->serverToClient);
    //sub
    } else if (!strcmp(cmd, SUB_CMD) && toksLen == 2 && 
            !has_space_colon_newline(toks[1])) {

        handle_sub_cmd(client, stringMap, toks[1]); 
        fflush(client->serverToClient);

    //unsub
    } else if (!strcmp(cmd, UNSUB_CMD) && toksLen == 2 &&
            !has_space_colon_newline(toks[1])) {

        handle_unsub_cmd(client, stringMap, toks[1]);
        fflush(client->serverToClient);

    //pub
    } else if (!strcmp(cmd, PUB_CMD) && toksLen == 3 && 
            !has_space_colon_newline(toks[1]) &&
            !has_space_colon_newline(toks[2])) {

        handle_pub_cmd(client, stringMap, toks[1], toks[2]);
        fflush(client->serverToClient);

    //invalid command type
    } else {
        fprintf(client->serverToClient, INVALID_MSG);
        fflush(client->serverToClient);
    }
}

typedef struct {
    int fd;
    StringMap* stringMap;

} ThreadArgs;

void* handle_client(void* arg) {
    ThreadArgs* ta = (ThreadArgs*)arg;
    
    int fd = ta->fd;
    int fd2 = dup(fd);

    FILE* clientToServer = fdopen(fd, "r");
    FILE* serverToClient = fdopen(fd2, "w");
    Client* client = create_client(NULL, clientToServer, serverToClient);

    char* line;
    while ((line = read_line(clientToServer))) {
        handle_client_msg(line, client, ta->stringMap);
    }

    fflush(stdout);
    pthread_exit(NULL);
}


void server_infinite_loop(int listenFd, StringMap* stringMap) {
    while (true) {
        //Block waiting for a new connection
        int fd = accept(listenFd, 0, 0); 

        ThreadArgs* ta = malloc(sizeof(ThreadArgs*));
        ta->fd = fd;
        ta->stringMap = stringMap;

        pthread_t threadId;
        pthread_create(&threadId, NULL, handle_client, ta);

        //ensures thread will give resouces back once terminated
        pthread_detach(threadId);
    }
}


int main(int argc, char** argv) {
    Parameters cmdArgs = parse_command_line(argc, argv);
    int listeningFd = open_socket(cmdArgs);
    StringMap* sm = stringmap_init();
    server_infinite_loop(listeningFd, sm);
}


















