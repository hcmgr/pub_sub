//server.c//
//------------//
//This file contains the main server-side functionality
//------------//

#include <csse2310a4.h>
#include <csse2310a3.h>
#include "clientList.h"
#include "shared.h"
#include "stringmap.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>

//useful constants
#define INVALID_NUM -1
#define MIN_NUM_ARGS 2
#define MAX_NUM_ARGS 3
#define CONNECTIONS_INDEX 1
#define PORTNUM_INDEX 2
#define MIN_PORT 1024
#define MAX_PORT 65535
#define TCP 0
#define DEFAULT_PORT 0
#define HOST_IP "localhost"
#define SPACE ' '
#define NAME_CMD "name"
#define SUB_CMD "sub"
#define UNSUB_CMD "unsub"
#define PUB_CMD "pub"
#define INVALID_MSG ":invalid\n"
#define MAX_CMD_FIELDS 3

char** split_line_max(char* line, char delim, int maxToks);

//server error codes
enum ErrorCodes {
    SUCCESS,
    USAGE_ERROR,
    PORTNUM_ERROR
};

/* Defines the Parameters structure which holds the following command line
 * arguments given to psserver:
 *      
 *      maxConnections - maximum number of concurrent connections to server
 *                    permitted
 *      portnum - indicates which localhost port psserver is listening on
 *      service - string version of portnum
 * */
typedef struct { 
    int maxConnections;
    int portnum;
    char* service;
} Parameters;

typedef struct {
    int clientsCurr;
    int clientsAll;
    int pub;
    int sub;
    int unsub;
} Stats;

enum StatChangeCodes {
    INC_CLIENTS_CURR,
    DEC_CLIENTS_CURR,
    INC_CLIENTS_ALL,
    INC_PUB,
    INC_SUB,
    INC_UNSUB
};

typedef struct {
    int fd;
    StringMap* stringMap;
    sem_t* stringMapLock;
    Stats* stats;
    sem_t* statsLock;
} ClientThreadArgs;

void init_lock(sem_t* l, int numAllowed) {
    sem_init(l, 0, numAllowed);
}

void take_lock(sem_t* l) {
    sem_wait(l);
}

void release_lock(sem_t* l) {
    sem_post(l);
}

void update_stat(ClientThreadArgs* cta, int statType) {
    Stats* stats = cta->stats;
    take_lock(cta->statsLock);
    switch (statType) {
        case INC_CLIENTS_CURR:
            stats->clientsCurr++;
            break;
        case DEC_CLIENTS_CURR:
            stats->clientsCurr--;
            break;
        case INC_CLIENTS_ALL:
            stats->clientsAll++;
            break;
        case INC_PUB:
            stats->pub++;
            break;
        case INC_SUB:
            stats->sub++;
            break;
        case INC_UNSUB:
            stats->unsub++;
            break;
    }
    release_lock(cta->statsLock);
}

Stats* stats_init() {
    Stats* stats = malloc(sizeof(Stats));
    memset(stats, 0, sizeof(Stats));
    return stats;
}

ClientThreadArgs* init_client_thread_args(StringMap* stringMap, Stats* stats) {
    ClientThreadArgs* ta = malloc(sizeof(ClientThreadArgs));
    memset(ta, 0, sizeof(ClientThreadArgs));
    ta->stringMap = stringMap;
    ta->stats = stats;

    //stringMap lock
    sem_t* smLock = malloc(sizeof(sem_t));
    init_lock(smLock, 1);
    ta->stringMapLock = smLock;

    //stats lock
    sem_t* statsLock = malloc(sizeof(sem_t));
    init_lock(statsLock, 1);
    ta->statsLock = statsLock;
    return ta;
}


/* general_error
 * -------------
 * For a given error (encoded by 'errorCode'), print out a descrptive message
 * and exit with the appropriate code.
 *
 * errorCode - encodes the specific error being handled
 * */
void general_error(int errorCode) {
    switch (errorCode) {
        case USAGE_ERROR:
            fprintf(stderr, "Usage: psserver connections [portnum]\n");
            exit(USAGE_ERROR);
        case PORTNUM_ERROR:
            fprintf(stderr, "psserver: unable to open socket for listening\n");
            exit(PORTNUM_ERROR);
    }
    return;
}

/* print_statistics
 * ----------------
 * Prints out the given set of statistics server emits when it received 
 * SIGHUP
 *
 * s - statistics struct 
 * */
void print_statistics(Stats* stats) {
    fprintf(stderr, "Connected clients:%d\n", stats->clientsCurr);
    fprintf(stderr, "Completed clients:%d\n", stats->clientsAll);
    fprintf(stderr, "pub clients:%d\n", stats->pub);
    fprintf(stderr, "sub clients:%d\n", stats->sub);
    fprintf(stderr, "unsub clients:%d\n", stats->unsub);
}

/* parse_command_line
 * ------------------
 * Retreives the command line arguments given to psserver and populates 
 * a Parameters structure with said arguments.
 *
 * NOTE: validity of all arguments is checked for 
 * 
 * argc - number of command line arguments
 * argv - array of command line arguments
 *
 * Returns:
 *      a Parameters structure populated with the given command line args
 * 
 * Exits with:
 *      1 - incorrect number of args received, connections arg not 
 *          non-negative integer or port number out of range
 * */
Parameters parse_command_line(int argc, char** argv) {
    //check number of args given is valid
    if (!(argc >= MIN_NUM_ARGS && argc <= MAX_NUM_ARGS)) {
        general_error(USAGE_ERROR); 
    }

    int portnum = DEFAULT_PORT;
    char* service = NULL;
    int maxConnections = string_to_int(argv[CONNECTIONS_INDEX]);
    
    //check connections arg is valid
    if (maxConnections == INVALID_NUM) {
        general_error(USAGE_ERROR); 
    }

    //check portnum is valid
    if (argc == MAX_NUM_ARGS) {
        service = argv[PORTNUM_INDEX];
        portnum = string_to_int(argv[PORTNUM_INDEX]);
        //not a non-negative integer
        if (portnum == INVALID_NUM) {
            general_error(USAGE_ERROR);
        }
        //not in range
        if (!(portnum == DEFAULT_PORT  || 
                    (portnum >= MIN_PORT && portnum <= MAX_PORT))) {
           general_error(USAGE_ERROR); 
        }
    }
    //if reached this point, all args are valid
    //NOTE: still haven't checked whether psserver can open the given port
    Parameters cmdArgs;
    memset(&cmdArgs, 0, sizeof(Parameters));
    cmdArgs.maxConnections = maxConnections;
    cmdArgs.portnum = portnum;
    //if portnum is 0, service should be NULL
    cmdArgs.service = portnum ? service : NULL;

    return cmdArgs;
}

int open_socket(Parameters cmdArgs) {
    //get address info of port to listen on 
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET; //IPv4
    hints.ai_socktype = SOCK_STREAM; //byte stream (TCP)
    hints.ai_flags = AI_PASSIVE; //listen on all server's interfaces (IP's)
    if (getaddrinfo(HOST_IP, cmdArgs.service, &hints, &ai)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //create socket, allow its rapid reuse and bind to given port
    int listeningFd = socket(AF_INET, SOCK_STREAM, TCP);
    int optVal = 1; 
    setsockopt(listeningFd, SOL_SOCKET, SO_REUSEADDR, &optVal, sizeof(int));
    bind(listeningFd, (struct sockaddr*)ai->ai_addr, sizeof(struct sockaddr));

    //retreive which port we're listening on 
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(struct sockaddr_in));
    socklen_t addrLen = sizeof(struct sockaddr_in);
    if (getsockname(listeningFd, (struct sockaddr*) &addr, &addrLen)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //indicate socket is willing to accept connections
    if (listen(listeningFd, cmdArgs.maxConnections) < 0) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }
    
    //print port listening on and return socket fd
    printf("%u\n", ntohs(addr.sin_port));
    return listeningFd;
}

void handle_name_cmd(Client* client, char* name) { 
    //ignore duplicate name
    if (client->name) {
        return; 
    } 
    client->name = name;
    return;
}

bool handle_sub_cmd(Client* client, ClientThreadArgs* cta, char* topic) { 
    StringMapItem* currItem = NULL;
    take_lock(cta->stringMapLock);
    //loop through list of topics
    while ((currItem = stringmap_iterate(cta->stringMap, currItem))) {
        if (!strcmp(currItem->key, topic)) {
            //add client to list of clients subbed to given topic
            add_client(currItem->item, client);            
            release_lock(cta->stringMapLock);
            //increment num successful sub requests 
            update_stat(cta, INC_SUB); 
            return true;
        }
    }
    release_lock(cta->stringMapLock);
    //topic doesn't exist - create it
    ListItem* head = init_client_list(client, false);

    int result = stringmap_add(cta->stringMap, topic, head);
    if (result) {
        //increment num successful sub requests (only if topic validly added)
        update_stat(cta, INC_SUB); 
    }
    return result;
}

bool handle_unsub_cmd(Client* client, ClientThreadArgs* cta, char* topic, 
        bool isDisconnecting) { 

    StringMapItem* currItem = NULL;
    take_lock(cta->stringMapLock);
    //loop through list of topics
    while ((currItem = stringmap_iterate(cta->stringMap, currItem))) {
        if (!strcmp(currItem->key, topic)) {
            //remove the client
            ListItem* newHead = remove_client(currItem->item, client);
            // newHead NULL if client wasn't in list
            if (newHead) {
                currItem->item = newHead; 
            }
            release_lock(cta->stringMapLock);

            //increment num successful unsub requests 
            //successful if: not disconnecting and client was in the list
            if (!isDisconnecting && newHead) {
                update_stat(cta, INC_UNSUB);
            }

            return newHead;
        }
    }
    release_lock(cta->stringMapLock);
    //topic doesn't exist
    return false;
}

bool handle_pub_cmd(Client* client, ClientThreadArgs* cta, char** toks) {
    StringMapItem* mapItem = NULL;
    char* topic = toks[1];
    char* value = toks[2];
    take_lock(cta->stringMapLock);
    //loop through list of topics
    while ((mapItem = stringmap_iterate(cta->stringMap, mapItem))) {
        if (!strcmp(mapItem->key, topic)) {
            update_stat(cta, INC_PUB);
            //loop through the list of all clients subbed to the topic
            ListItem* clientItem = mapItem->item;
            while (clientItem) {
                Client* currClient = clientItem->client;
                if (currClient) { //check client is not a placeholder
                    fprintf(currClient->serverToClient, "%s:%s:%s\n",
                            client->name, topic, value);
                    fflush(currClient->serverToClient);

                }
                clientItem = clientItem->next;
            }
            release_lock(cta->stringMapLock);
            return true;
        }
    }
    release_lock(cta->stringMapLock);
    //topic doesn't exist
    return false;
}

void handle_client_msg(char* msg, Client* client, ClientThreadArgs* ta) {
    char** toks = split_line_max(strdup(msg), SPACE, MAX_CMD_FIELDS);
    int toksLen = string_array_length(toks);
    if (toksLen < 2) {
        fprintf(client->serverToClient, INVALID_MSG);
        fflush(client->serverToClient);
        return;
    }

    //handle each of the command types
    char* cmd = toks[0];
    //name 
    if (!strcmp(cmd, NAME_CMD) && toksLen == 2 &&
            !has_space_colon_newline(toks[1])) {

        handle_name_cmd(client, toks[1]);
        fflush(client->serverToClient);
    //sub
    } else if (!strcmp(cmd, SUB_CMD) && toksLen == 2 && 
            !has_space_colon_newline(toks[1])) {

        handle_sub_cmd(client, ta, toks[1]); 
        fflush(client->serverToClient);

    //unsub
    } else if (!strcmp(cmd, UNSUB_CMD) && toksLen == 2 &&
            !has_space_colon_newline(toks[1])) {

        handle_unsub_cmd(client, ta, toks[1], false);
        fflush(client->serverToClient);

    //pub
    } else if (!strcmp(cmd, PUB_CMD) && toksLen >= 3 && 
            !has_space_colon_newline(toks[1])) {
        handle_pub_cmd(client, ta, toks);
        fflush(client->serverToClient);

    //invalid command type
    } else {
        fprintf(client->serverToClient, INVALID_MSG);
        fflush(client->serverToClient);
    }
}

void* handle_client_thread(void* arg) {
    ClientThreadArgs* cta = (ClientThreadArgs*)arg;
    update_stat(cta, INC_CLIENTS_CURR); //increment num current clients 
    
    int fd = cta->fd;
    int fd2 = dup(fd);

    FILE* clientToServer = fdopen(fd, "r");
    FILE* serverToClient = fdopen(fd2, "w");
    Client* client = create_client(NULL, clientToServer, serverToClient);

    char* line;
    while ((line = read_line(clientToServer))) {
        handle_client_msg(line, client, cta);
    }

    update_stat(cta, DEC_CLIENTS_CURR); //decrement num current clients
    update_stat(cta, INC_CLIENTS_ALL); //increment total num clients

    fflush(stdout);
    pthread_exit(NULL);
}

typedef struct {
    Stats* stats; 
    sigset_t* signalMask;
    sem_t* statsLock;

} StatsThreadArgs;

StatsThreadArgs* init_stats_thread_args(Stats* stats, sem_t* statsLock) {
    //initialise struct itself
    StatsThreadArgs* sta = malloc(sizeof(StatsThreadArgs));  
    memset(sta, 0, sizeof(StatsThreadArgs));
    sta->stats = stats;
    sta->statsLock = statsLock;

    //initialise the signal mask
    sigset_t* mask = malloc(sizeof(sigset_t));
    sigemptyset(mask);
    sigaddset(mask, SIGHUP);
    int result = pthread_sigmask(SIG_BLOCK, mask, NULL); 
    if (result != SUCCESS) {
        //handle error
    }
    sta->signalMask = mask;

    return sta;
}

void* statistics_thread(void* arg) {
    StatsThreadArgs* sta = (StatsThreadArgs*)arg;
    int signal;
    while(true) {
        int result = sigwait(sta->signalMask, &signal);
        if (result != SUCCESS) {
            //handle error
        }
        take_lock(sta->statsLock);
        print_statistics(sta->stats);
        release_lock(sta->statsLock);
    }
}

void start_statistics_thread(StatsThreadArgs* sta) {
    pthread_t threadId;
    pthread_create(&threadId, NULL, statistics_thread, sta);
    pthread_detach(threadId);
}

void server_infinite_loop(int listenFd, ClientThreadArgs* threadArgs) {
    while (true) {
        //Block waiting for a new connection
        int fd = accept(listenFd, 0, 0); 

        //set new thread's network socket fd
        threadArgs->fd = fd;

        //spawn new thread
        pthread_t threadId;
        pthread_create(&threadId, NULL, handle_client_thread, threadArgs);

        //ensures thread will give resouces back once terminated
        pthread_detach(threadId);
    }
}


int main(int argc, char** argv) {
    Parameters cmdArgs = parse_command_line(argc, argv);
    int listeningFd = open_socket(cmdArgs);
    StringMap* stringMap = stringmap_init(); //shared string map 
    Stats* stats = stats_init(); //shared statistics structure
    ClientThreadArgs* cta = init_client_thread_args(stringMap, stats);
    StatsThreadArgs* sta = init_stats_thread_args(cta->stats, cta->statsLock);
    start_statistics_thread(sta);
    server_infinite_loop(listeningFd, cta);
}

/* ALL DYNAMICALLY ALLOCATED MEMORY USED IN THIS PROJECT:
 *
 * server.c:
 *      -threadArgs
 *          -all malloc'd memory in threadArgs is shared 
 *           (sm, smLock, stats, statsLock)
 *          -therefore, only free once SERVER terminates
 * shared.c:
 *      -add_new_line()
 *          -string we return is malloc'd
 *
 * clientList.c:
 *      -create_client()
 *          -client we return
 *      -init_client_list()
 *          -ListItem*  we return (HEAD of list)
 *      -add_client()
 *          -ListItem* we add
 *              -therefore, every linked list of clients is entirely made up
 *               of malloc'd memory
 * */

//------------------------------------------------------------------------//
//------------------------------------------------------------------------//

/* split_line_max
 * --------------
 * Splits the given line by the given delimiter, but limits the number of 
 * tokens returned to maxToks
 *
 *  eg: if: 
 *      line = "pub bingus sneeds big govamint"
 *      delim = ' '
 *      maxToks = 3
 *
 *      output = {"pub", "bingus", "sneeds big govamint"}
 *
 * Returns the array of string tokens
 * */
char** split_line_max(char* line, char delim, int maxToks) { 
    char** toks = split_line(strdup(line), delim);
    //get combined length of extra strings
    int arrLen = string_array_length(toks);
    int combinedStrLen = 0;
    for (int i = maxToks - 1; i < arrLen; i++) {
        combinedStrLen += strlen(toks[i]);
    }
    //build up string made up of the extra strings
    char* combinedStr = calloc((combinedStrLen + 1), sizeof(char));
    for (int i = maxToks - 1; i < arrLen; i++) {
        strcat(combinedStr, strdup(toks[i]));
        if (i != arrLen - 1) {
            strcat(combinedStr, " ");
        }
    }
    //add initial tokens and combined str into new string array
    char** newToks = calloc(maxToks + 1, sizeof(char*));
    for (int i = 0; i < maxToks - 1; i++) {
        newToks[i] = strdup(toks[i]);
    }
    newToks[maxToks - 1] = combinedStr;
    free(toks);
    return newToks;
}























