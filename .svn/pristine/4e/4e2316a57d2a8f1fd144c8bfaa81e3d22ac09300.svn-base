//client.c//
//-----------//
//This file contains the main client-side functionality
//-----------//

#include <csse2310a4.h>
#include <csse2310a3.h>
#include "shared.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>


//helpful constants
#define PORT_NUM_INDEX 1
#define NAME_INDEX 2
#define TOPICS_INDEX 3
#define NUM_NON_TOPIC_ARGS 3
#define NAME_ERROR 1
#define TOPICS_ERROR 2
#define NODE "localhost"
#define TCP 0
#define READ 0
#define WRITE 1

/* Defines the Parameters structure which holds the following command line
 * arguments given to psclient:
 *
 *      service - service name/string version of the port number
 *      portnum - port to connect to that psserver is listening on
 *      clientName - name to be associated with the client
 *      topics - list of topics client wishes to subsribe to (optional)
 * */
typedef struct {
    char* service;
    int portnum;
    char* clientName;
    char** topics;
} Parameters;

/* Defines the SocketEnds structure which holds the read and write ends of 
 * the socket connecting the client to the server:
 *
 *      serverToClient - read end
 *      clientToServer - write end
 * */
typedef struct {
    FILE* serverToClient;
    FILE* clientToServer;
} SocketEnds;

//client error codes
enum ExitCodes {
    SUCCESS,
    NUM_ARGS_ERROR,
    NAME_OR_TOPICS_ERROR,
    PORT_ERROR,
    CONNECTION_CLOSED,
    ADDRESS_ERROR
};

/* general_error
 * -------------
 * For a given error (encoded by 'errorCode'), print out a descriptive
 * message and exit with the appropriate code.
 *
 * errorCode - encodes the specific error being handled
 * extraInfo - general string that used to make error messages more 
 *             specialised/descriptive (eg: port number unable to connect to)
 * nameOrTopics - 1 if handling a 'name' error, 2 if handling a 'topics' error,
 *                0 (NULL) otherwise (necessary because these errors have 
 *                the same exit code)
 *
 * */
void general_error(int errorCode, char* extraInfo, int nameOrTopics) {
    switch(errorCode) {
        //insufficient command line args
        case NUM_ARGS_ERROR:
            fprintf(stderr, "Usage: psclient portnum name [topic] ...\n");
            exit(NUM_ARGS_ERROR);
        case NAME_OR_TOPICS_ERROR:
            //invalid name argument
            if (nameOrTopics == NAME_ERROR) {
                fprintf(stderr, "psclient: invalid name\n");
            }
            //invalid topics argument(s)
            if (nameOrTopics == TOPICS_ERROR) {
                fprintf(stderr, "psclient: invalid topic\n");
            }
            exit(NAME_OR_TOPICS_ERROR);
        //unable to connect to the given port
        case PORT_ERROR:
            fprintf(stderr, "psclient: unable to connect to port %s\n",
                    extraInfo);
            exit(PORT_ERROR);
        //network connection to server closed
        case CONNECTION_CLOSED:
            fprintf(stderr, "psclient: server connection terminated\n");
            exit(CONNECTION_CLOSED);
    }
    return;
}


/* parse_command_line
 * ------------------
 * Retreives the command line arguments given to psclient and populates a 
 * Parameters structure with said arguments.
 *
 * NOTE: validity of all arguments is checked for 
 *
 * argc - number of command line arguments
 * argv - array of command line arguments
 * 
 * Returns:
 *      a Parameters structure populated with the given command line args
 *
 * Exits with:
 *      1 - incorrect number of args received
 *      2 - invalid name or topic
 *      3 - client can't connect to given port/service
 *
 * */
Parameters parse_command_line(int argc, char** argv) {
    //check number of arguments given
    if (argc < 3) {
        general_error(NUM_ARGS_ERROR, NULL, 0);
    }

    //retreive arguments from argv
    char* service = argv[PORT_NUM_INDEX];
    char* name = argv[NAME_INDEX];
    char** topics = calloc((argc - NUM_NON_TOPIC_ARGS)+1, sizeof(char*));

    //check all topics are validly configured (if so, add to topics array)
    for (int i = TOPICS_INDEX; i < argc; i++) {
        if (has_space_colon_newline(argv[i])){
            general_error(NAME_OR_TOPICS_ERROR, NULL, TOPICS_ERROR);
        }
        topics[i - TOPICS_INDEX] = argv[i]; 
    }

    //check name arg is validly configured
    if (has_space_colon_newline(name)) {
        general_error(NAME_OR_TOPICS_ERROR, NULL, NAME_ERROR);
    }

    //if this point is reached, args are validly configured
    //NOTE: haven't checked whether port/service can be conneceted to 
    Parameters cmdArgs;
    memset(&cmdArgs, 0, sizeof(Parameters));
    cmdArgs.service = service; 
    cmdArgs.clientName = name;
    cmdArgs.topics = topics;
    return cmdArgs;
}

/* connect_to_server
 * -----------------
 * Connects the client socket to the given node/address on the given 
 * port/service. The method populates a structure holding the read and write
 * ends of the socket.
 *
 * node - address of node to connect to
 * service - port number in our case
 *
 * Returns:
 *      a SocketEnds structure holding the read and write ends of the socket
 *
 * Exits:
 *  
 *
 * */
SocketEnds connect_to_server(char* node, char* service) {
    //get address info struct
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET; //IPv4
    hints.ai_socktype= SOCK_STREAM; //byte stream (TCP) 
    if (getaddrinfo(node, service, &hints, &ai)){ //returns 0 on success
        freeaddrinfo(ai);
        general_error(PORT_ERROR, service, 0); //exits here
    }

    //connect socket to server address
    int fd = socket(AF_INET, SOCK_STREAM, TCP);
    if (connect(fd, (struct sockaddr*)ai->ai_addr,
                sizeof(struct sockaddr))) { //returns 0 on success

        general_error(PORT_ERROR, service, 0); // exits here
    }
    //now socket is connected to server, separate read and write streams
    int fd2 = dup(fd);
    FILE* serverToClient = fdopen(fd, "r");
    FILE* clientToServer = fdopen(fd2, "w");
    //populate SocketEnds struct
    SocketEnds fds;
    memset(&fds, 0, sizeof(SocketEnds));
    fds.serverToClient = serverToClient;
    fds.clientToServer = clientToServer;
    return fds;
}

void send_name(FILE* fd, char* name) {
    fprintf(fd, "name %s\n", name);
}

void subscribe(FILE* fd, char* topic) {
    fprintf(fd, "sub %s\n", topic);
}

void unsubscribe(FILE* fd, char* topic) {
    fprintf(fd, "unsub %s\n", topic);
}

void publish(FILE* fd, char* topic, char* value) {
    fprintf(fd, "pub %s %s\n", topic, value);
}

void send_starting_msgs(SocketEnds fds, Parameters cmdArgs) {
    //send name
    send_name(fds.clientToServer, cmdArgs.clientName);
    //subscribe to each topic
    while (cmdArgs.topics[0]) {
        subscribe(fds.clientToServer, cmdArgs.topics[0]);
        cmdArgs.topics++;
    }
    fflush(fds.clientToServer);
}

/* print_lines_loop
 * ----------------
 * Reads from the given network socket and outputs what it receives to 
 * stdout.
 *
 * serverToClient - network socket to listen on 
 *
 * */
void print_lines_loop(FILE* serverToClient) {
    char* line;
    while ((line = read_line(serverToClient))) {
        printf("%s\n", line);
        fflush(serverToClient);
    }
}


/* send_lines_loop
 * ---------------
 * A thread that reads a line from stdin and sends what it receives to the 
 * given network socket.
 *
 * arg - void* version of a network socket
 *
 * */
void* send_lines_loop(void* arg) {

    FILE* clientToServer = (FILE*)arg;
    char* line;
    char* lineToSend;
    while ((line = read_line(stdin))) {
        lineToSend = add_new_line(line);
        fprintf(clientToServer, lineToSend);
        fflush(clientToServer);
    }
    exit(4);
    pthread_exit(NULL);
}


/* spawn_thread
 * ------------
 * Spawns the client thread that continously reads lines from stdin and sends
 * them to the server
 *
 * serverToClient - network socket
 *
 * */
void spawn_thread(FILE* serverToClient) {
    pthread_t threadId;
    pthread_create(&threadId, NULL, send_lines_loop, serverToClient);
    pthread_detach(threadId);
}

int main(int argc, char** argv) {
    Parameters cmdArgs = parse_command_line(argc, argv);
    SocketEnds fds = connect_to_server(NODE, cmdArgs.service);
    send_starting_msgs(fds, cmdArgs);
    spawn_thread(fds.clientToServer);
    print_lines_loop(fds.serverToClient);
}









