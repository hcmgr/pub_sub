#include <csse2310a4.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>


//helpful constants
#define PORT_NUM_INDEX 1
#define NAME_INDEX 2
#define TOPICS_INDEX 3
#define NUM_NON_TOPIC_ARGS 3
#define NAME_ERROR 1
#define TOPICS_ERROR 2

/* Defines the Parameters structure which holds the following command line
 * arguments given to psclient:
 *
 *      service - service name/string version of the port number
 *      portnum - port to connect to that psserver is listening on
 *      clientName - name to be associated with the client
 *      topics - list of topics client wishes to subsribe to (optional)
 * */
typedef struct {
    char* service;
    int portnum;
    char* clientName;
    char** topics;
} Parameters;

//client error codes
enum ExitCodes {
    SUCCESS,
    NUM_ARGS_ERROR,
    NAME_OR_TOPICS_ERROR,
    PORT_ERROR,
    CONNECTION_CLOSED
};

/* general_error
 * -------------
 * For a given error (encoded by 'errorCode'), print out a descriptive
 * message and exit with the appropriate code.
 *
 * errorCode - encodes the specific error being handled
 * extraInfo - general string that used to make error messages more 
 *             specialised/descriptive (eg: port number unable to connect to)
 * nameOrTopics - 1 if handling a 'name' error, 2 if handling a 'topics' error,
 *                0 (NULL) otherwise (necessary because these errors have 
 *                the same exit code)
 *
 * */
void general_error(int errorCode, char* extraInfo, int nameOrTopics) {
    switch(errorCode) {
        //insufficient command line args
        case NUM_ARGS_ERROR:
            fprintf(stderr, "Usage: psclient portnum name [topic] ...\n");
            exit(NUM_ARGS_ERROR);
        case NAME_OR_TOPICS_ERROR:
            //invalid name argument
            if (nameOrTopics == NAME_ERROR) {
                fprintf(stderr, "psclient: invalid name\n");
            }
            //invalid topics argument(s)
            if (nameOrTopics == TOPICS_ERROR) {
                fprintf(stderr, "psclient: invalid topic\n");
            }
            exit(NAME_OR_TOPICS_ERROR);
        //unable to connect to the given port
        case PORT_ERROR:
            fprintf(stderr, "psclient: unable to connect to port %s\n",
                    extraInfo);
            exit(PORT_ERROR);
        //network connection to server closed
        case CONNECTION_CLOSED:
            fprintf(stderr, "psclient: server connection terminated\n");
            exit(CONNECTION_CLOSED);
    }
    return;
}

/* check_spaces_colons_newlines
 * ----------------------------
 * Checks whether the given string contains spaces, colons or newlines
 * 
 * str - given string to check
 *
 * Returns:
 *        true iff the string contains a space, colon or newline, false 
 *        otherwise
 * */
bool check_spaces_colons_newlines(char* str) {
    while (str[0]) {
        if (str[0] == ' ' || str[0] == ':' || str[0] == '\n') {
            return false;
        }
        str++;
    }
    return true;
}

Parameters parse_command_line(int argc, char** argv) {
    //check number of arguments given
    if (argc < 3) {
        general_error(NUM_ARGS_ERROR, NULL, 0);
    }

    //retreive arguments from argv
    char* service = argv[PORT_NUM_INDEX];
    char* name = argv[NAME_INDEX];
    char** topics = malloc(sizeof(char*) * (argc - NUM_NON_TOPIC_ARGS));

    //check all topics are validly configured (if so, add to topics array)
    for (int i = TOPICS_INDEX; i < argc; i++) {
        if (!check_spaces_colons_newlines(argv[i])) {
            general_error(NAME_OR_TOPICS_ERROR, NULL, TOPICS_ERROR);
        }
        topics[i - TOPICS_INDEX] = argv[i]; 
    }

    //check name arg is validly configured
    if (!check_spaces_colons_newlines(name)) {
        general_error(NAME_OR_TOPICS_ERROR, NULL, NAME_ERROR);
    }

    //if this point is reached, args are validly configured
    //NOTE: haven't checked whether port/service can be conneceted to 
    Parameters cmdArgs;
    memset(&cmdArgs, 0, sizeof(Parameters));
    cmdArgs.service = service; 
    cmdArgs.clientName = name;
    cmdArgs.topics = topics;
    return cmdArgs;
}

int main(int argc, char** argv) {
    Parameters cmdArgs = parse_command_line(argc, argv);
}









