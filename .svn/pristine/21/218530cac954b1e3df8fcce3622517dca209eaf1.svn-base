//server.c//
#include <csse2310a4.h>
#include <csse2310a3.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>

//useful constants
#define MIN_NUM_ARGS 2
#define MAX_NUM_ARGS 3
#define INVALID_NUM -1
#define CONNECTIONS_INDEX 1
#define PORTNUM_INDEX 2
#define MIN_PORT 1024
#define MAX_PORT 65535
#define TCP 0
#define DEFAULT_PORT 0
#define HOST_IP "localhost"

//server error codes
enum ErrorCodes {
    SUCCESS,
    USAGE_ERROR,
    PORTNUM_ERROR
};

/* Defines the Parameters structure which holds the following command line
 * arguments given to psserver:
 *      
 *      maxConnections - maximum number of concurrent connections to server
 *                    permitted
 *      portnum - indicates which localhost port psserver is listening on
 *      service - string version of portnum
 * */
typedef struct { 
    int maxConnections;
    int portnum;
    char* service;
} Parameters;

/* Defines the Client structure which holds all relevant information about
 * a client. Client structures are stored in linked lists with other Client's
 * depending on their topics. 
 *
 *      name - name client gave themself
 *      clientToServer - read end (from server's point of view) of socket
 *      serverToClient - write end (from client's point of view) of socket
 *      topics - string array holding the topics the client has specified
 *
 * */
typedef struct { 
    char* name;
    FILE* clientToServer;
    FILE* serverToClient;
    char** topics;
} Client;

Client* create_client(char* name, FILE* clientToServer, FILE* serverToClient) {
    Client* client = malloc(sizeof(Client*));
    client->name = name;
    client->clientToServer = clientToServer;
    client->serverToClient = serverToClient;
    return client;
}

void print_client(Client* client) {
    printf("name: %s\n", client->name);
}

/* Defines the ListItem structure which is what we store in our linked list
 * of clients who follow the same topic.
 *
 *      client - pointer to client we're storing
 *      next - next client in the list
 * */
typedef struct ListItem ListItem;

struct ListItem {
    Client* client;
    struct ListItem* next;
};

ListItem* init_client_list(Client* client) {
    ListItem* li = malloc(sizeof(ListItem*));
    li->client = client;
    return li;
}


/* add_client
 * ----------
 * Adds the given client to the given linked list of clients.
 *
 * head - head of linked list 
 * client - pointer client to add
 *
 * */
void add_client(ListItem* head, Client* client) {
    //construct ListItem for new client
    ListItem* li = malloc(sizeof(ListItem*));
    memset(li, 0, sizeof(ListItem));
    li->client = client;
    //add client to end of list
    ListItem* curr = head;
    while (curr->next) {
        curr = curr->next;
    }
    curr->next = li;
}

/* remove_client
 * -------------
 * Removes the given client from the given linked list of clients.
 *
 * head - head of linked list
 * client - pointer to client to remove
 *
 * Returns:
 *      pointer to the head of the new linked list
 * */
ListItem* remove_client(ListItem* head, Client* client) {
    //special case of removing head
    if (head->client == client) {
        return head->next; 
    }

    //find client in list 
    ListItem* prev = head;
    ListItem* curr = head->next;
    ListItem* temp;
    while (curr) {
        if (curr->client == client) {
            prev->next = curr->next;
            return head;
        }
        temp = curr;
        curr = curr->next;
        prev = temp;
    }
    //client wasn't in list
    return NULL;
}


/* general_error
 * -------------
 * For a given error (encoded by 'errorCode'), print out a descrptive message
 * and exit with the appropriate code.
 *
 * errorCode - encodes the specific error being handled
 * */
void general_error(int errorCode) {
    switch (errorCode) {
        case USAGE_ERROR:
            fprintf(stderr, "Usage: psserver connections [portnum]\n");
            exit(USAGE_ERROR);
        case PORTNUM_ERROR:
            fprintf(stderr, "psserver: unable to open socket for listening\n");
            exit(PORTNUM_ERROR);
    }
    return;
}

/* string_to_int 
 * ---------------
 * Attempts to convert the given string to a non-negative integer
 *
 * str - string to be converted
 *
 * Returns:
 *      - -1 if the string cannot be converted to a non-negative integer OR;
 *      - the integer if it CAN BE converted
 * */
int string_to_int(char* str) {
    //handle portnum = 0 case
    if (str[0] == '0') {
        return 0;
    }
    //handle all other cases
    //checks all characters are digits
    for (int i = 0; i < strlen(str); i++) {
        if (!isdigit(str[i])) {
            return INVALID_NUM;
        }
    }
    return atoi(str);
}

/* parse_command_line
 * ------------------
 * Retreives the command line arguments given to psserver and populates 
 * a Parameters structure with said arguments.
 *
 * NOTE: validity of all arguments is checked for 
 * 
 * argc - number of command line arguments
 * argv - array of command line arguments
 *
 * Returns:
 *      a Parameters structure populated with the given command line args
 * 
 * Exits with:
 *      1 - incorrect number of args received, connections arg not 
 *          non-negative integer or port number out of range
 * */
Parameters parse_command_line(int argc, char** argv) {
    //check number of args given is valid
    if (!(argc >= MIN_NUM_ARGS && argc <= MAX_NUM_ARGS)) {
        general_error(USAGE_ERROR); 
    }

    int portnum = DEFAULT_PORT;
    char* service = NULL;
    int maxConnections = string_to_int(argv[CONNECTIONS_INDEX]);
    
    //check connections arg is valid
    if (maxConnections == INVALID_NUM) {
        general_error(USAGE_ERROR); 
    }

    //check portnum is valid
    if (argc == MAX_NUM_ARGS) {
        service = argv[PORTNUM_INDEX];
        portnum = string_to_int(argv[PORTNUM_INDEX]);
        //not a non-negative integer
        if (portnum == INVALID_NUM) {
            general_error(USAGE_ERROR);
        }
        //not in range
        if (!(portnum == DEFAULT_PORT  || 
                    (portnum >= MIN_PORT && portnum <= MAX_PORT))) {
           general_error(USAGE_ERROR); 
        }
    }
    //if reached this point, all args are valid
    //NOTE: still haven't checked whether psserver can open the given port
    Parameters cmdArgs;
    memset(&cmdArgs, 0, sizeof(Parameters));
    cmdArgs.maxConnections = maxConnections;
    cmdArgs.portnum = portnum;
    //if portnum is 0, service should be NULL
    cmdArgs.service = portnum ? service : NULL;

    return cmdArgs;
}

int open_socket(Parameters cmdArgs) {
    //get address info of port to listen on 
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET; //IPv4
    hints.ai_socktype = SOCK_STREAM; //byte stream (TCP)
    hints.ai_flags = AI_PASSIVE; //listen on all server's interfaces (IP's)
    if (getaddrinfo(HOST_IP, cmdArgs.service, &hints, &ai)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //create socket, allow its rapid reuse and bind to given port
    int listeningFd = socket(AF_INET, SOCK_STREAM, TCP);
    int optVal = 1; 
    setsockopt(listeningFd, SOL_SOCKET, SO_REUSEADDR, &optVal, sizeof(int));
    bind(listeningFd, (struct sockaddr*)ai->ai_addr, sizeof(struct sockaddr));

    //retreive which port we're listening on 
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(struct sockaddr_in));
    socklen_t addrLen = sizeof(struct sockaddr_in);
    if (getsockname(listeningFd, (struct sockaddr*) &addr, &addrLen)) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }

    //indicate socket is willing to accept connections
    if (listen(listeningFd, cmdArgs.maxConnections) < 0) {
        //can't listen on given port
        general_error(PORTNUM_ERROR); //exits here
    }
    
    //print port listening on and return socket fd
    printf("%u\n", ntohs(addr.sin_port));
    return listeningFd;
}

void* handle_client(void* fdPtr) {
    int fd = *(int*)fdPtr;
    free(fdPtr);

    int numBytesRead;
    char buffer[1024];
    while ((numBytesRead = read(fd, buffer, 1024)) > 0) {
        write(fd, buffer, numBytesRead);    
    }

    ////create read and write socket ends for ease of use
    //int fd2 = dup(fd);
    //FILE* clientToServer = fdopen(fd, "r");
    //FILE* serverToClient = fdopen(fd2, "w");

    ////continously read input from client until EOF (socket disconnects)
    //char* line;
    //while ((line = read_line(clientToServer))) {
    //    fprintf(serverToClient, "%s\n", line); 
    //}

    fflush(stdout);
    pthread_exit(NULL);
}

void server_infinite_loop(int listenFd) {
    while (true) {
        //Block waiting for a new connection
        int fd = accept(listenFd, 0, 0); 

        //start thread to handle specific client
        int* fdPtr = malloc(sizeof(int));
        *fdPtr = fd;
        pthread_t threadId;
        pthread_create(&threadId, NULL, handle_client, fdPtr);

        //ensures thread will give resouces back once terminated
        pthread_detach(threadId);
    }
}


int main(int argc, char** argv) {
    //Parameters cmdArgs = parse_command_line(argc, argv);
    //int listeningFd = open_socket(cmdArgs);
    //server_infinite_loop(listeningFd);
    Client* client1 = create_client("Harry", NULL, NULL);
    Client* client2 = create_client("Ron", NULL, NULL);
    Client* client3 = create_client("Harmione", NULL, NULL);
    ListItem* head = init_client_list(client1);
    add_client(head, client2);
    add_client(head, client3);
    head = remove_client(head, client1);
    ListItem* curr = head;
    while(curr) {
        print_client(curr->client); 
        curr = curr->next;
    }
}


















